# 常にキャッチがある... (笑)

Promise は、同期制御フローをエミュレートするように設計されています。
Promise 以外で例外がスローされると、それはスタックを遡ってバブルアップし catch ブロックによってキャッチされるか、グローバルコンテキストにまで達しスローされます。

以下のコードでは、各式が順に評価されます。
いずれかの式が例外をスローした場合、**すべての後続の式は実行されず、** catch ブロックがキャッチして処理します。

```js
try {
  doStuff()
  doMoreStuff()
} catch (err) {
  complainAboutJavascript(err);
}
```

Promise では、これと非常に似た制御フローを実現できます
（すべての関数が Promise を返す前提です）：

```js
doStuff()
.then(doMoreStuff)
.then(null, complainAboutJavascript);
```

最後から2行目は fulfill ハンドラであり、最後の行は reject ハンドラですが、ふたつを纏めるべきでしょうか？
**いいえ！**最初はその方が分かりやすいように思えるかもしれませんが、 `doMoreStuff` がエラーを投げた場合にどうなるか考えてみてください。



Reject された Promise が返された場合、その処理のために **次の** 拒否ハンドラが探されます。
忘れないでください： Promise は、一度 reject されたら **決して** resolve されることはありません。
したがって、常に reject ハンドラをあなたの Promise チェーンの一番下に置くのがベストプラクティスです（キャッチブロックとよく似ています）。

同期**と**非同期コードの両方に同じ問題があることは、指摘に値します。
拒否ハンドラ自体がエラーをスローした場合、困ったことになるという問題です。
多くの Promise ライブラリは、単純に未知のエラーを処理する `done` ハンドラを提供することで、この問題を改善しようとしています。

経験則はこれです：

> もしあなたの Promise で呼び出し元に値を**返さない**場合、
> 例外がキャッチされない事態を防ぐために `done` ハンドラをつけてください。

例を以下に示します。

```js
doStuff()
.then(doMoreStuff)
.then(null, complainAboutJavascript)
.done();
```

## 課題

関数のチェインを作成しその**すべてを**コンソールに表示することで、学んだ事を確認していきましょう。

1.文字列 `"OH NOES"` で `Error` をスローする `alwaysThrows` 関数を作成してください。

2.第1引数（整数）を表示し、その引数に +1 した値を返す `iterate` 関数を作成してください。

3.Q の `fcall` を使って反復メソッドをラップする Promise を作成し(※訳注 今は Q.fcall を使わなくても、Promise.resolve で大丈夫です) `iterate` 関数を合計10回実行しようとする Promise チェーンを作成してください。

4.チェーンの一番下の reject ハンドラとして `console.log` を渡してください。

5.5回目の `iterate` の呼び出しの後に `alwaysThrows` の呼び出しを挿入してください。

正しく実行できた場合、コードは 1,2,3,4,5, "[Error：OH NOES]" と出力します。

スローされた例外が reject された Promise に変化し、それにより Promise チェーン内の最初に利用可能な reject ハンドラに移動する点がポイントです。


## ボーナス

reject ハンドラを `console.log` から `alwaysThrows` に入れ替えてみてください。あなたのプログラムは、グローバルコンテキストで例外をスローします！ああ！
上記の方法を使用してこれを修正してください。



